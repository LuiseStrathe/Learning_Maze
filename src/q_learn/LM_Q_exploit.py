# Run exploitation of explored q-table with Q-learning

## update Q-table with randomized (noise) q- policy runs 


### IMPORTS ###

import sys
from os.path import exists
from multiprocessing import Process, Pool, Queue

sys.path.insert(1, "/home/luise/Documents/DataScience/Projects/Learning_Maze/Learning_Maze")
from src.maze.LM_Environment import *
from src.maze.LM_Data import *
from LM_Q_Helper import *



### PARAMETERS ###

name_q_table = 'q_table_s1_07'
path = 'Learning_Maze/data/q_learn/policies/'

batch_size = 1000    # games per epoch and CPU within max_loop_time
CPUs = 18          # num games batches in parralel per epoch
num_epochs = 20      # epochs total
noise = .9           # pval of moves adjusted by [-.5, .5] * noise_range, default: .5
alpha = 0.001        # learning rate, default: .001

sight       = 1
wmax, wmin  = 9, 6
mmax, mmin  = 4, 1
bmax, bmin  = 25, 15



### LOAD Q-TABLE ###

if exists(f'{path}{name_q_table}.csv'):
    print('Load Q-table', name_q_table, 'and save backup...')
    policy = pd.read_csv(f'{path}{name_q_table}.csv')
    policy.to_csv(f'{path}backup/{name_q_table}_{str(datetime.now())}.csv', index=False)
    
else:
    print('Load Q-table from exploration', name_q_table, '...')
    policy = pd.read_csv(f'{path}{name_q_table}_explored.csv').iloc[:, :6]

### UPDATE Q-TABLE WITH FULLY RANDOM RUNS ###

print('Semi-random-policy runs...')

for counter in range(num_epochs):
    print(f'\nRun epoch {counter + 1} of {num_epochs}...')
    
    ##### RUN Q-GAMES WITH NOISE #####
    
    procs = []
    Gs = [Queue() for i in range(CPUs)]
        
    print('   Play', CPUs, 'threads with', batch_size, 'games each...')
    for CPU in range(CPUs):
        proc = Process(target=run_q_noise_games, args=(batch_size, policy, noise, wmax, wmin, sight, mmax, mmin, bmax, bmin, Gs[CPU]))
        procs.append(proc)
        proc.start() 
        
    games_data = [G.get() for G in Gs]
        
    for proc in procs:
        proc.join() 
        proc.close()   
    
    games_data = pd.concat(games_data)  
    wins = games_data[games_data.score > 0].count()[0]
    print ('Games finished, # records:', len(games_data))
    print('win_rate in steps (!):', wins, round(wins/ len(games_data), 3) * 100, '%')    
    print()
    
    ##### UPDATE Q-TABLE #####
    
    print('Update Q-table with random runs...')
    policy = exploit_q_table(policy, games_data, alpha)
    
    
    ##### SAVE Q-TABLE #####
    print()
    policy.to_csv(f'{path}{name_q_table}.csv', index=False)


### END ###

print('\nUpdate Q-table done. Backup safed.')
print('#############################')

